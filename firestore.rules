rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    ////////////////////////////////
    // Blockframes Administrators //
    ////////////////////////////////

    // blockframe admins can access ALL the db.
    // this overwrites every other rules.
    match /{document=**} {
      allow read, write: if isBlockframesAdmin(userId());
    }

    match /blockframesAdmin/{userId} {
      allow read: if userId() == userId;
      allow write: if false;
    }

    function isBlockframesAdmin(userId) {
      return exists(/databases/$(database)/documents/blockframesAdmin/$(userId));
    }

    ///////////////////
    /// COLLECTIONS ///
    ///////////////////

    // Note: Add a verification of each document ID => {id: ID_SHOULD_BE_EQUAL_TO_PATH}
    // Add schemas validators for document update/create => ISSUE#650

    /// USERS RULES ///
    // TODO: Create a "public users" collection to get non sensitive user data => ISSUE#1359

    match /users/{userId} {
    	allow read: if userId() == existingData().uid
      	|| (isSignedIn() && isOrgMember(userId, userOrgId()));
    	// We can read user data from the same organization as us until we got public users collection.
    	allow update: if isSignedIn()
      	&& userId() == incomingData().uid
        && isNotUpdatingField('uid')
        && isNotUpdatingField('email')
    	allow create: if userId() == incomingData().uid;
      allow delete: if userId() == existingData().uid;
    }

    /// NOTIFICATIONS RULES ///

    match /notifications/{notificationId} {
    	allow read, update: if userId() == existingData().userId // @TODO (#2461) Update here if renamming field userId
        || currentUser().orgId == existingData().organization.id;
    	allow create, delete: if false;
    }

    /// INVITATIONS RULES ///
    
    // Functions
    // Send the invitation
    function isHost() {
      return userOrgId() == existingData().fromOrg.id
        || userId() == existingData().fromUser.uid;
    }
    // Receive the invitation
    function isGuest() {
      return userId() == existingData().toUser.uid
        || currentUser().email == existingData().toEmail;
    }

    // Rules
    match /invitations/{invitationId} {
    	allow read: if isHost() || isGuest();

      allow create: 
        // Event
        if incomingData().type == 'event'
        // Invitation to org
        || userId() == incomingData().fromUser.uid
      	|| userOrgId() == incomingData().fromOrg.id
        || orgCan('isAdmin', userOrgId(), incomingData().docId);

      // Update is used to change status only. Allowed to recepients only
      // @TODO (#2500) should be handled by a backend function to prevent ugly rules
    	allow update: if 
        // Event
        (
          incomingData().type == 'event' && isGuest()
          || (orgCan('isAdmin', userOrgId(), incomingData().docId))
        )
        &&
        (
          isNotUpdatingField('id')
          && isNotUpdatingField('app')
          && isNotUpdatingField('type')
          && isNotUpdatingField('mode')
          && isNotUpdatingField('status')
          && isNotUpdatingField('date')
          && isNotUpdatingField('fromOrg')
          && isNotUpdatingField('fromUser')
          && isNotUpdatingField('toOrg')
          && isNotUpdatingField('toUser')
          && isNotUpdatingField('toEmail')
          && isNotUpdatingField('docId')
          && isNotUpdatingField('processedId')
        );

      allow delete: if
        // Event
        (incomingData().type == 'event' && isHost())
        ||
        (isOrgAdmin(userId(), existingData().fromOrg.id) || userId() == existingData().toUser.uid);
    }

    /// ORGANIZATION RULES ///

    match /orgs/{orgId} {
    	allow create: if isSignedIn()
      	&& incomingData().status == 'pending'
        && documentIdChecked(orgId, 'orgs');
      allow update: if isSignedIn()
      	&& isNotUpdatingField('status')
        && isNotUpdatingField('id')
        && documentIdChecked(orgId, 'orgs');
      allow delete: if isSuperAdmin(userId(), orgId);
      allow read: if isSignedIn();

      match /{subCollection}/{documents=**} {
        allow read, write;
      }
    }

    /// PERMISSIONS RULES ///
    match /docsIndex/{docId} {
      // index of every doc create with a permission doc associated:
      // essential for isBrandNewDocument.
      allow read, write: if false;
    }

    match /permissions/{orgId} {
    	allow read: if isOrgMember(userId(), orgId);
      allow create: if (isOrgAdmin(userId(), orgId)
      	  && incomingData().id == orgId
          && documentIdChecked(orgId, 'permissions')
        ) || isCreatingOrganization(orgId);
			allow update: if isOrgAdmin(userId(), orgId)
      	&& incomingData().id == orgId
        && documentIdChecked(orgId, 'permissions')
        && incomingData().id == existingData().id;

      match /documentPermissions/{docId} {
        allow read: if isOrgMember(userId(), orgId);
        allow create: if isOrgMember(userId(), orgId)
          && incomingData().id == docId
          && isBrandNewDocument(docId);
        allow update: if isOrgAdmin(userId(), orgId)
          && incomingData().id == docId
          && incomingData().id == existingData().id;
      }
    }

    /// MOVIES RULES ///

    match /movies/{movieId} {
    	// We allow all movie read as Archipel Content is a catalog of public movies.
      allow read: if userHasValidOrg();
      allow create: if userHasValidOrg()
      	&& documentIdChecked(movieId, 'movies')
        && canCreateNewPermissions(userOrgId(), movieId);
      allow update: if isOrgAdmin(userId(), userOrgId())
        && documentIdChecked(movieId, 'movies')
        && incomingData().id == existingData().id
        && orgCan('canUpdate', userOrgId(), movieId);
      allow delete: if orgCan('canDelete', userOrgId(), movieId)
      	&& isOrgAdmin(userId(), userOrgId());

    }

    /// CONTRACTS RULES ///

    match /contracts/{contractId} {
    	allow read: if isParty(userOrgId()) || orgCan('canRead', userOrgId(), contractId);
      allow create: if canCreateNewPermissions(userOrgId(), contractId); // this depends on the fact that you can create a permission document in your own org.
      allow update: if orgCan('canUpdate', userOrgId(), contractId);
      allow delete: if orgCan('canDelete', userOrgId(), contractId);

      match /versions/{versionId} {
        allow read: if isParty(userOrgId()) || orgCan('canRead', userOrgId(), contractId);
        allow write: if false;
      }
    }

    match /publicContracts/{publicContractId} {
      allow read: if userHasValidOrg();
      allow write: if false;
    }

    /// DISTRIBUTION RIGHTS RULES ///
    match /{path=**}/distributionRights/{rightId} {
    	allow write: if true; // @TODO #1388 Only if contract.status  === 'unknown' ?
      allow read: if true; // @TODO #1388 Only if licensee.orgId == currentUser.orgId || if licensor.orgId == currentUser.orgId
    }

    /// EVENTS RULES ///
    match /events/{eventId} {
    	allow write: if true; // @TODO #1388 Only if contract.status  === 'unknown' ?
      allow read: if true; // @TODO #1388 Only if licensee.orgId == currentUser.orgId || if licensor.orgId == currentUser.orgId
	    match /{document=**} {
        allow read, write: if true;
      }    
		}

    /// META ///
    match /_META/_MAINTENANCE {
      allow read;
      allow write: if false;
    }

    /////////////////
    /// FUNCTIONS ///
    /////////////////

    // Check the requested data.
    function existingData() {
      return resource.data;
    }

    // Check the data after being updated.
    function incomingData() {
      return request.resource.data;
    }

    function currentUser() {
      return request.auth;
    }

    function userId() {
      return currentUser().uid;
    }

  	// Check if the user is logged in the app.
    function isSignedIn() {
      return currentUser() != null;
    }

  	function userOrgId() {
    	return get(/databases/$(database)/documents/users/$(userId())).data.orgId;
  	}

    // Check if the user belongs to an organization.
    function userHasValidOrg() {
    	return get(/databases/$(database)/documents/orgs/$(userOrgId())).data.status == "accepted";
    }

    // Check if the param ID is equal to the data ID.
    function documentIdChecked(docId, collection) {
    	return docId == getAfter(/databases/$(database)/documents/$(collection)/$(docId)).data.id;
    }

  	function isSuperAdmin(userId, orgId) {
    	return getOrgPermissions(orgId).roles[userId] == "superAdmin";
  	}

    function isOrgAdmin(userId, orgId) {
    	// /!\ Carefull, parentheses needed for operator precedence to work
    	return (getOrgPermissions(orgId).roles[userId] == "admin")
        || (isSuperAdmin(userId, orgId));
    }

    function isOrgMember(userId, orgId) {
    	return (getOrgPermissions(orgId).roles[userId] == "member")
      	|| (isOrgAdmin(userId, orgId));
    }

    function isParty(orgId) {
    	return orgId in resource.data.partyIds;
    }

    function getDocumentPermissions(orgId, docId) {
    	return get(/databases/$(database)/documents/permissions/$(orgId)/documentPermissions/$(docId)).data;
    }

    function isBrandNewDocument(docId) {
      // check that no corresponding doc exists in the index (you have to get invited to create perm for a document that ALREADY exists)
      return !exists(/databases/$(database)/documents/docsIndex/$(docId));
    }

    function canCreateNewPermissions(orgId, docId) {
    	return getAfter(/databases/$(database)/documents/permissions/$(orgId)/documentPermissions/$(docId)).data.canCreate == true;
    }

    function isCreatingOrganization(orgId) {
			return userId() in getAfter(/databases/$(database)/documents/orgs/$(orgId)).data.userIds
      	&& exists(/databases/$(database)/documents/orgs/$(orgId)) == false;
    }

    function getOrgPermissions(orgId) {
    	return get(/databases/$(database)/documents/permissions/$(orgId)).data;
    }

		// Parameter "action" can either be "canCreate", "canRead", "canUpdate" or "canDelete"
    function orgCan(action, orgId, docId) {
      return (getDocumentPermissions(orgId, docId).ownerId == orgId)
        || (getDocumentPermissions(orgId, docId).admin == true)
        || (getDocumentPermissions(orgId, docId)[action] == true);
    }

    // We check that the field is not sent or if field sent is equal to actual
    function isNotUpdatingField(fieldName) {
			return !incomingData().keys().hasAll([fieldName]) || (existingData.keys().hasAll([fieldName]) && incomingData()[fieldName] == existingData[fieldName]);
    }
  }
}
