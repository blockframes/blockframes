rules_version = '2';

///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                               DATABASE RULES                                        ///
///                              This document describes the database rules                             ///
///  Documentation @see https://www.notion.so/cascade8/Database-rules-80024b4805b74e1a98ac154f4afeaad7  ///
///////////////////////////////////////////////////////////////////////////////////////////////////////////

service cloud.firestore {
  match /databases/{database}/documents {

    ////////////////////////////////
    // Blockframes Administrators //
    ////////////////////////////////

    /// RULES ///

    // blockframes admins can access ALL the db.
    // this overwrides every other rules.
    match /{document=**} {
      allow read, write: if isBlockframesAdmin(userId());
    }

    match /blockframesAdmin/{userId} {
      allow read: if userId() == userId;
      allow write: if false;
    }

    /// FUNCTIONS ///

    function isBlockframesAdmin(userId) {
      return exists(/databases/$(database)/documents/blockframesAdmin/$(userId));
    }


    ////////////////////////////////
    // Commons Collections        //
    ////////////////////////////////


    match /docsIndex/{docId} {
      // index of every doc created with a permission doc associated
      // essential for isBrandNewDocument.
      allow read, write: if false;
    }

    match /_META/_MAINTENANCE {
      allow read: if true;
      allow write: if false;
    }

    /////////////////////////////////////////////////////////////////////////////////
    ///                                 COLLECTIONS                               ///
    ///             rules defined at the collections or document level            ///
    /////////////////////////////////////////////////////////////////////////////////


    ////////////////////////////////
    // USER RULES                 //
    ////////////////////////////////

    /// RULES ///

    match /users/{userId} {
      // TODO (#1359): We can read user data from the same organization as us until we got public users collection.
    	allow read: if userId() == existingData().uid	|| (isSignedIn() && isOrgMember(userId, userOrgId()));
    	allow update: if isOnlyUpdatingAllowedUserFields();
    	allow create: if userId() == incomingData().uid
        && isRequestFieldValueEqualTo(['uid'], userId);
      allow delete: if userId() == existingData().uid;
    }

    // TODO (#1359): publicUser rules goes here.

    /// FUNCTIONS ///

    function isOnlyUpdatingAllowedUserFields() {
      // Only "firstName" and "lastName" can be updated.
      return isSignedIn()
      	&& userId() == incomingData().uid
        && isNotUpdatingField('uid')
        && isNotUpdatingField('email')
        && isNotUpdatingField('orgId')
    }

    ////////////////////////////////
    // NOTIFICATIONS RULES        //
    ////////////////////////////////

    /// RULES ///

    match /notifications/{notificationId} {
    	allow read: if userId() == existingData().toUserId;
    	allow update: if isOnlyMarkingNofitifcationAsRead();
    	allow create, delete: if false;
    }

    /// FUNCTIONS ///

    function isOnlyMarkingNofitifcationAsRead() {
      // Only "isRead" can be updated.
      return userId() == existingData().toUserId
        && isNotUpdatingField('id')
        && isNotUpdatingField('date')
        && isNotUpdatingField('toUserId')
        && isNotUpdatingField('type')
        // Notifcations subjects
        && isNotUpdatingField('docId')
        && isNotUpdatingField('user')
        && isNotUpdatingField('organization')
        && isNotUpdatingField('movies');
    }

    ////////////////////////////////
    // INVITATIONS RULES          //
    ////////////////////////////////

    /// RULES ///
    
    match /invitations/{invitationId} {
    	allow read: if isInvitationSender() || isInvitationRecepient();
      allow create: if isInvitationSender()
        && isRequestFieldValueEqualTo(['status'], 'pending')
        && (
          !incomingData().keys().hasAll(['docId']) // no docId
          || orgCan('isAdmin', userOrgId(), incomingData().docId) // user org is admin of docId
        )
        && isRequestFieldValueEqualTo(['id'], invitationId);
    	allow update: if isOnlyChangingInvitationStatus();
      allow delete: if isInvitationSender();
    }

    /// FUNCTIONS ///

    function isInvitationSender() {
      return isOrgAdmin(userId(), existingData().fromOrg.id)
        || userId() == existingData().fromUser.uid;
    }

    function isInvitationRecepient() {
      return isOrgAdmin(userId(), existingData().toOrg.id)
        || userId() == existingData().toUser.uid;
    }

    function isOnlyChangingInvitationStatus() {
      // Update is used to change status only. Allowed to recepients only
      // @TODO (#2500) should be handled by a backend function to prevent ugly rules
      // Only "status" can be updated.
      return isInvitationRecepient()
        &&
        (
          isNotUpdatingField('id')
          && isNotUpdatingField('app')
          && isNotUpdatingField('type')
          && isNotUpdatingField('mode')
          && isNotUpdatingField('status')
          && isNotUpdatingField('date')
          && isNotUpdatingField('fromOrg')
          && isNotUpdatingField('fromUser')
          && isNotUpdatingField('toOrg')
          && isNotUpdatingField('toUser')
          && isNotUpdatingField('docId')
          && isNotUpdatingField('processedId')
        );
    }


    ////////////////////////////////
    // ORGANIZATION RULES         //
    ////////////////////////////////

    /// RULES ///
  
    match /orgs/{orgId} {
      allow read: if isSignedIn();
    	allow create: if isSignedIn()
        && isRequestFieldValueEqualTo(['status'], 'pending')
        && isRequestFieldValueEqualTo(['id'], orgId)
      allow update: if isSignedIn()
      	&& isNotUpdatingField('status')
        && isNotUpdatingField('created')
        && isNotUpdatingField('appAccess') // @TODO #2585 if method works for objects
        && isNotUpdatingField('id');
      allow delete: if isSuperAdmin(userId(), orgId);
    }

    ////////////////////////////////
    // PERMISSIONS RULES          //
    ////////////////////////////////

    /// RULES ///

    match /permissions/{orgId} {
    	allow read: if isOrgMember(userId(), orgId);
      allow create: if isRequestFieldValueEqualTo(['id'], orgId)
        && ( isOrgAdmin(userId(), orgId) || isCreatingOrganization(orgId));
			allow update: if isOrgAdmin(userId(), orgId)
      	&& isNotUpdatingField('id');

      match /documentPermissions/{docId} {
        allow read: if isOrgMember(userId(), orgId);
        allow create: if isOrgMember(userId(), orgId)
          && isRequestFieldValueEqualTo(['id'], docId)
          && isBrandNewDocument(docId);
        allow update: if isOrgAdmin(userId(), orgId)
          && isNotUpdatingField('id');
      }
    }

    /// FUNCTIONS ///

    function isBrandNewDocument(docId) {
      // checks that no corresponding doc exists in the index (you have to get invited to create perm for a document that ALREADY exists)
      return !exists(/databases/$(database)/documents/docsIndex/$(docId));
    }

    ////////////////////////////////
    // MOVIES RULES               //
    ////////////////////////////////

    /// RULES ///

    match /movies/{movieId} {
    	// @TODO (#2049) We allow all movie read as Archipel Content is a catalog of public movies.
      allow read: if userHasValidOrg();
      allow create: if userHasValidOrg()
        && isRequestFieldValueEqualTo(['main', 'storeConfig', 'status'], 'draft')
      	&& isRequestFieldValueEqualTo(['id'], movieId)
        && canCreateNewPermissions(userOrgId(), movieId);
      allow update: if isOrgAdmin(userId(), userOrgId())
        && isNotUpdatingField('id')
        && isNotUpdatingField('_meta')
        && isNotUpdatingField('_type')
        && isNotUpdatingField('movie.main.storeConfig.status') // @TODO #2585 if method works for deep path
        && orgCan('canUpdate', userOrgId(), movieId);
      allow delete: if orgCan('canDelete', userOrgId(), movieId)
      	&& isOrgAdmin(userId(), userOrgId());

      match /distributionRights/{rightId} {
        // @TODO (#2606 #2049) We allow all distributionRights reads as we need it to search avails
        allow read: if userHasValidOrg();
        allow create: if isRequestFieldValueEqualTo(['id'], rightId)
          && isRequestFieldValueEqualTo(['status'], 'draft')
        allow update: if isNotUpdatingField('id')
          && isNotUpdatingField('status')
          && isNotUpdatingField('contractId');
        allow delete: if orgCan('canDelete', userOrgId(), movieId)
          && isOrgAdmin(userId(), userOrgId());
      }
    }

    ////////////////////////////////
    // CONTRACTS RULES            //
    ////////////////////////////////

    /// RULES ///

    match /contracts/{contractId} {
    	allow read: if isParty(userOrgId()) || orgCan('canRead', userOrgId(), contractId);
      allow create: if canCreateNewPermissions(userOrgId(), contractId)
        && isRequestFieldValueEqualTo(['lastVersion', 'status'], 'draft')
        && isRequestFieldValueEqualTo(['id'], contractId); // @TODO #2485 remettre or not setted pr les create id
      allow update: if orgCan('canUpdate', userOrgId(), contractId)
        && isNotUpdatingField('id') //  @TODO #2485  et si l'id n'existe pas et est rajout√© ? rajouter un second argument
        && isNotUpdatingField('type')
        && isNotUpdatingField('lastVersion.status'); // @TODO #2585 if method works for deep path
      allow delete: if orgCan('canDelete', userOrgId(), contractId);

      match /versions/{versionId} {
        allow read: if isParty(userOrgId()) || orgCan('canRead', userOrgId(), contractId);
        allow write: if false;
      }
    }

    match /publicContracts/{publicContractId} {
      allow read: if userHasValidOrg();
      allow write: if false;
    }

    ////////////////////////////////
    // EVENTS RULES               //
    ////////////////////////////////

    /// EVENTS RULES ///
    match /events/{eventId} {
    	allow read: if userHasValidOrg() 
        && (
          !existingData().isPrivate 
          || existingData().ownerId == userId()
          || ( existingData().ownerId == userOrgId() && isOrgAdmin(userId(), userOrgId()) )
        );
      allow create: if userHasValidOrg() 
        && isRequestFieldValueEqualTo(['id'], eventId)
        && ( isRequestFieldValueEqualTo(['ownerId'], userId()) || isRequestFieldValueEqualTo('ownerId', userOrgId()) );
      allow update: if userHasValidOrg() 
        && isNotUpdatingField('id')
        && ( isRequestFieldValueEqualTo(['ownerId'], userId()) || isRequestFieldValueEqualTo('ownerId', userOrgId()) );
      allow delete: if userHasValidOrg()
        && ( existingData().ownerId == userId() || ( existingData().ownerId == userOrgId() && isOrgAdmin(userId(), userOrgId()) ) );
		}


    /////////////////////////////////////////////////////////////////////////////////
    ///                                  FUNCTIONS                                ///
    ///                  set of functions to help building rules                  ///
    /////////////////////////////////////////////////////////////////////////////////

    // Check the requested data.
    function existingData() {
      return resource.data;
    }

    // Check the data after being updated.
    function incomingData() {
      return request.resource.data;
    }

    function currentUser() {
      return request.auth;
    }

    function userId() {
      return currentUser().uid;
    }

  	// Check if the user is logged in the app.
    function isSignedIn() {
      return currentUser() != null;
    }

  	function userOrgId() {
    	return get(/databases/$(database)/documents/users/$(userId())).data.orgId;
  	}

    // Check if the user belongs to an organization.
    function userHasValidOrg() {
    	return get(/databases/$(database)/documents/orgs/$(userOrgId())).data.status == "accepted";
    }


  	function isSuperAdmin(userId, orgId) {
    	return getOrgPermissions(orgId).roles[userId] == "superAdmin";
  	}

    function isOrgAdmin(userId, orgId) {
    	// /!\ Carefull, parentheses needed for operator precedence to work
    	return (getOrgPermissions(orgId).roles[userId] == "admin")
        || (isSuperAdmin(userId, orgId));
    }

    function isOrgMember(userId, orgId) {
    	return (getOrgPermissions(orgId).roles[userId] == "member")
      	|| (isOrgAdmin(userId, orgId));
    }

    function isParty(orgId) {
    	return orgId in resource.data.partyIds;
    }

    function getDocumentPermissions(orgId, docId) {
    	return get(/databases/$(database)/documents/permissions/$(orgId)/documentPermissions/$(docId)).data;
    }

    function canCreateNewPermissions(orgId, docId) {
    	return getAfter(/databases/$(database)/documents/permissions/$(orgId)/documentPermissions/$(docId)).data.canCreate == true;
    }

    function isCreatingOrganization(orgId) {
			return userId() in getAfter(/databases/$(database)/documents/orgs/$(orgId)).data.userIds
      	&& exists(/databases/$(database)/documents/orgs/$(orgId)) == false;
    }

    function getOrgPermissions(orgId) {
    	return get(/databases/$(database)/documents/permissions/$(orgId)).data;
    }

		// Parameter "action" can either be "canCreate", "canRead", "canUpdate" or "canDelete"
    function orgCan(action, orgId, docId) {
      return (getDocumentPermissions(orgId, docId).ownerId == orgId)
        || (getDocumentPermissions(orgId, docId).admin == true)
        || (getDocumentPermissions(orgId, docId)[action] == true);
    }

    // We check that the field is not sent or if field sent is equal to actual
    function isNotUpdatingField(fieldName) {
			return !incomingData().keys().hasAll([fieldName]) || (existingData().keys().hasAll([fieldName]) && incomingData()[fieldName] == existingData()[fieldName]);
    }

    // Incoming field path must be setted with a value equal to "value"
    function isRequestFieldValueEqualTo(fieldArray, value) {
      return (incomingData()[fieldArray[0]][fieldArray[1]][fieldArray[2]] == value) 
        || (incomingData()[fieldArray[0]][fieldArray[1]] == value)
        || (incomingData()[fieldArray[0]] == value);
    }

  }
}
